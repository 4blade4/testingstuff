local username = username or 'dev'

local DEBUG_MODE = false
local services = setmetatable({}, { __index = function(self, key) return game:GetService(key) end })
local client = services.Players.LocalPlayer;

local http_request = syn and syn.request or http_request

local KickClient, LoadFromGithub do
	function KickClient(reason)
		return client:Kick(reason)
	end

	local function GetUrl(url)
		local response = http_request({ Url = url, Method = 'GET' })

		local success = response.Success;
		local body = response.Body;

		if not success then
			return false, 'Request failed. StatusCode: ' .. response.StatusCode
		end

		return true, body
	end

	function LoadFromGithub(owner, repo, file, branch)
		local url = 'https://raw.githubusercontent.com/' .. owner .. '/' .. repo .. '/' .. (branch or 'main') .. '/' .. file
		local success, body = GetUrl(url)

		if not success then
			return KickClient('Failed to fetch from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(body) }))
		end

		local fn, err = loadstring(body, '@' .. url)
		if not fn then
			return KickClient('Failed to load from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(err) }))
		end

		local results = { pcall(fn) }
		local success = table.remove(results, 1)

		if not success then
			return KickClient('Failed to execute from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(results[1]) }))
		end

		return unpack(results)
	end

	function LoadFromFile(path)
		local closure, err = loadstring(readfile(path), '@' .. path)
		assert(closure, err)
		return closure()
	end
end

if not DEBUG_MODE then
end

local ESP = DEBUG_MODE and LoadFromFile('ESP-lib/ESP.lua') 			or LoadFromGithub('wally-rblx', 'ESP-lib', 'ESP.lua')
local UI  = DEBUG_MODE and LoadFromFile('LinoriaLib/Library.lua') 	or LoadFromGithub('wally-rblx', 'LinoriaLib', 'Library.lua')

local ThemeManager = DEBUG_MODE and LoadFromFile('LinoriaLib/addons/ThemeManager.lua') or LoadFromGithub('wally-rblx', 'LinoriaLib', 'addons/ThemeManager.lua')
local SaveManager  = DEBUG_MODE and LoadFromFile('LinoriaLib/addons/SaveManager.lua')  or LoadFromGithub('wally-rblx', 'LinoriaLib', 'addons/SaveManager.lua')

local broom = DEBUG_MODE and NEON:belkworks'broom'  or LoadFromGithub('Belkworks', 'broom', 'init.lua', 'master')
local show  = DEBUG_MODE and NEON:belkworks'show' 	or LoadFromGithub('Belkworks', 'show',  'init.lua', 'master')

-- Library addons
ThemeManager:SetFolder('misc-projects')
SaveManager:SetFolder('misc-projects/bad-business')

ThemeManager:SetLibrary(UI)
SaveManager:SetLibrary(UI)

SaveManager:IgnoreThemeSettings()

local syn_context_set = syn and syn.set_thread_identity or setthreadidentity
local syn_context_get = syn and syn.get_thread_identity or getthreadidentity

do
	-- fart bypass
	syn.set_thread_identity(2)
	local s, e = pcall(PluginManager)
	syn.set_thread_identity(7)

	hookfunction(PluginManager, function(...)
		error(e)
	end)
end

-- Utilities
local Utilities = {}
do
	Utilities.MarkedJobIds = {}
	Utilities.Random = Random.new()

	local ServerList = services.TeleportService:GetTeleportSetting('BadBusinessServerHop')
	if ServerList then
		Utilities.MarkedJobIds = services.HttpService:JSONDecode(ServerList)
	end

	function Utilities.ServerHop(mode)
		table.insert(Utilities.MarkedJobIds, game.JobId)
		services.TeleportService:SetTeleportSetting('BadBusinessServerHop', services.HttpService:JSONEncode(Utilities.MarkedJobIds))

		local ServerListUrl = 'https://games.roblox.com/v1/games/%s/servers/public?cursor=%s'
		local Cursor = ''

		local ServerList = {}

		local Start = os.clock()
		while true do
			local success, body = pcall(httpget, game, string.format(ServerListUrl, game.PlaceId, Cursor))
			if not success then
				UI:Notify('Failed to fetch server list because: ' .. body .. '.\nRetrying in 2 seconds.')
				wait(2)

				continue
			end

			local success, decoded = pcall(services.HttpService.JSONDecode, services.HttpService, body)
			if not success then
				UI:Notify('Failed to decode server list because: ' .. decoded .. '.\nRetrying in 2 seconds.')
				wait(2)

				continue
			end

			for _, server in next, decoded.data do
				if table.find(Utilities.MarkedJobIds, server.id) then continue end
				if not server.playing then continue end
				if server.playing >= services.Players.MaxPlayers then continue end

				table.insert(ServerList, {
					id = server.id,
					count = server.playing,
				})
			end

			if not decoded.nextPageCursor then
				break
			end

			Cursor = decoded.nextPageCursor
		end

		if not next(ServerList) then
			return UI:Notify('Server hop failed: No servers found!')
		end

		UI:Notify('Hopping to another server...', 3)
		wait(1)

		local server = ServerList[Utilities.Random:NextInteger(1, #ServerList)]
		services.TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
	end
end

-- Auto hop
do
	local function OnPlayerKicked(ForceHop)
		local ErrorCode = services.GuiService:GetErrorCode()
		local Message = services.GuiService:GetErrorMessage()

		if ErrorCode == Enum.ConnectionError.DisconnectLuaKick then 	
			task.delay(0.5, function() services.GuiService:ClearError() end)

			if (ForceHop or Toggles.AutoHopKick.Value) then
				UI:Notify('Automatically hopping servers because we got kicked!')
				Utilities.ServerHop()
			else
				UI:Notify('You have been kicked!\nWaiting for user input...', 1e9)
			end
		end
	end

	Utilities.KickCon = services.GuiService.ErrorMessageChanged:Connect(function()
		Utilities.KickCon:Disconnect()
		OnPlayerKicked()

		services.GuiService.ErrorMessageChanged:Connect(function()
			services.GuiService:ClearError()
		end)
	end)

	task.spawn(OnPlayerKicked, true)
end

-- local tsLoader = require(game:GetService("ReplicatedStorage").TS)
local Tortoiseshell = table.foreach(getupvalues(tsLoader), function(key, val)
    if type(val) == 'table' and rawget(val, 'Signed') then
        local mt = getrawmetatable(val)
        local idx = mt and mt.__index
        
        if type(idx) == 'function' then
            local upvs = debug.getupvalues(idx)
            if type(upvs[1]) == 'table' and rawget(upvs[1], 'PhysicsProjectiles') then
                return upvs[1]
            end
        end
    end
end)

local Tortoiseshell = getupvalue(require(services.ReplicatedStorage:WaitForChild('TS')), 2)
game.ScriptContext:SetTimeout(0.1)

-- Character shit
local GetCharacter, GetTeam, GetPlayerFromCharacter, GetTeamColor
do
	function GetCharacter(player)
		return Tortoiseshell.Characters:GetCharacter(player)
	end

	function GetTeam(player)
		return Tortoiseshell.Teams:GetPlayerTeam(player)
	end

	function GetPlayerFromCharacter(character)
		return Tortoiseshell.Characters:GetPlayerFromCharacter(character)
	end

	function GetTeamColor(player)
		local IsTeamMate = ESP:IsTeamMate(player)
		return Tortoiseshell.Teams.Colors[IsTeamMate and 'Friendly' or 'Enemy']
	end

	ESP.Font = 'Monospace'
	ESP.HighlightColor = Color3.new(1, 1, 1)
	ESP.HighlightColorDark = UI:GetDarkerColor(Color3.new(1, 1, 1))

	ESP.Overrides.GetTeam = GetTeam
	ESP.Overrides.GetPlrFromChar = GetPlayerFromCharacter

	ESP.Overrides.IsTeamMate = function(player)
		return Tortoiseshell.Teams:ArePlayersFriendly(player, client)
	end

	ESP.Overrides.GetColor = function(character)
	    local player = ESP:GetPlrFromChar(character)
	    if not player then return nil end
    	
        if not ESP.TeamColor then
        	return ESP:IsTeamMate(player) and Options.AllyColor.Value or Options.EnemyColor.Value
        end

        return GetTeamColor(player)
	end
end

-- Aimbot
local Aimbot = {} do
	local function isInCircle(point, center, radius)
		local rX = point.x - center.x
		local rY = point.y - center.y

		return (rX*rX) + (rY*rY) <= radius*radius
	end

	local circle = ESP.Draw('Circle', {
		Position = workspace.CurrentCamera.ViewportSize / 2,
		Transparency = 1,
		NumSides = 16,
		Thickness = 1,
		Color = Color3.new(1, 1, 1),
		Visible = false,
		ZIndex = 2,
	})

	local outline = ESP.Draw('Circle', {
		Position = workspace.CurrentCamera.ViewportSize / 2,
		Transparency = 1,
		NumSides = 16,
		Thickness = 3,
		Color = Color3.new(0, 0, 0),
		Visible = false
	})

	function Aimbot.UpdateCircle(value)
		if type(value) == 'number' then outline.Radius = value; circle.Radius = value end
		if type(value) == 'boolean' then outline.Visible = value; circle.Visible = value end
		if typeof(value) == 'Color3' then circle.Color = value end
	end

	Aimbot.PartNames = {}

	local payload = require(game.ReplicatedStorage:findFirstChild('CharacterPayload', true))
	local scrambled = getupvalue(getconnections(workspace.Characters.ChildAdded)[1].Function, 6)

	table.sort(payload, function(p0, p1) return p0 < p1 end)

	for i, name in next, payload do
		Aimbot.PartNames[name] = scrambled[i]
	end


	function Aimbot.solveTime(proj_pos, proj_speed, target, gravity)
	    local diff = target - proj_pos;
	    local diffXZ = Vector3.new(diff.x, 0, diff.z);
	    local groundDist = diffXZ.magnitude;

	    local speed2 = proj_speed * proj_speed;
	    local speed4 = speed2 * speed2;

	    local y = diff.y;
	    local x = groundDist;

	    local gx = gravity * x;

	    local root = speed4 - gravity * (gravity * x * x + 2 * y * speed2);

	    if (root < 0) then return nil end

	    root = math.sqrt(root);

	    local sol = math.atan2(speed2 - root, gx);
	    local s0 = diffXZ.Unit * math.cos(sol) * proj_speed + Vector3.new(0, 1, 0) * math.sin(sol) * proj_speed;
	    local t = x / (math.cos(sol) * proj_speed);

	    return s0, t;
	end

	function Aimbot.VelocityPrediction(startpos, endpos, vel, speed) -- Kinematics is fun
    	return endpos + (vel * ((endpos-startpos).Magnitude/speed))
	end

	function Aimbot.GetAimBone()
		local choice = Options.HitBone.Value
		local bones = { 'Head', 'Torso' }
		local namesMap = { Torso = 'Abdomen' }

		if choice == 'Random' then
			choice = bones[math.random(#bones)]
		end

		return Aimbot.PartNames[namesMap[choice] or choice]
	end

	table.insert(ESP.Objects, { 
		Update = function() 
			outline.Position = workspace.CurrentCamera.ViewportSize / 2 
			circle.Position = workspace.CurrentCamera.ViewportSize / 2 
		end
	})

	services.RunService.Heartbeat:Connect(function(dt)
		local center = workspace.CurrentCamera.ViewportSize / 2

		local clientCharacter = GetCharacter(client)
		local clientTeam = GetTeam(client)

		if not clientCharacter then 
			return 
		end

		local Choices = {}
		for _, plr in next, services.Players:GetPlayers() do
			if plr == client then continue end

			local character = GetCharacter(plr)
			local hitbox = character and character:findFirstChild('Hitbox')
			local bone = hitbox and hitbox:findFirstChild(Aimbot.PartNames.Head)

			local health = character and character:findFirstChild'Health'
			local shield = health and health:findFirstChild'Shield'

			if character and (not ESP:IsTeamMate(plr)) and bone and (not shield) then
				local pos, vis = workspace.CurrentCamera:WorldToViewportPoint(bone.Position)
				if not vis then
					continue
				end

				local screenPos = Vector2.new(pos.X, pos.Y)
				if (Toggles.FOVCircle and Toggles.FOVCircle.Value) then 
					if (not isInCircle(screenPos, center, circle.Radius)) then
						continue
					end
				end

				if Toggles.VisibleCheck.Value then
					local origin = workspace.CurrentCamera.CFrame.p;
					local point = bone.CFrame.p

					local ray = Ray.new(origin, point - origin)
					local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, { workspace.CurrentCamera, workspace.Effects, workspace.Gameplay, workspace.Projectiles })

					if hit and (not hit:IsDescendantOf(character)) then
						continue
					end
				end

				local distance = math.floor((screenPos - center).magnitude)
				table.insert(Choices, {
					Player = plr,
					Distance = distance,
					Character = character,
				})
			end
		end

		table.sort(Choices, function(a, b)
			return a.Distance < b.Distance
		end)

		local choice = Choices[1]
		if choice then
			local plr = choice.Player;

			Aimbot.target = plr;
			if Toggles.HighlightTarget.Value then
				ESP.Highlighted = choice.Character
			end
		else
			Aimbot.target = nil;
			ESP.Highlighted = nil
		end
	end)
end

-- ESP
do
	local HighlightStore = {}
	local function CreateChams(player, character)
		local cleaner = broom()

		local highlight = UI:Create('Highlight', {
			Enabled = false,
			Adornee = character,
			Parent = game.CoreGui,
		})

		cleaner:give(character:GetPropertyChangedSignal('Parent'):Connect(function()
			if not character:IsDescendantOf(workspace) then
				cleaner:clean()
			end
		end))

		cleaner:give(highlight)
		cleaner:give(function() HighlightStore[player] = nil end)

		HighlightStore[player] = highlight
	end

	local function onCharacterAdded(character)
		local player = GetPlayerFromCharacter(character)

		if player == client then return end
		if not player then return end

		ESP:Add(character, { Name = player.Name, Player = player, PrimaryPart = character:WaitForChild('Root') })
		CreateChams(player, character)

		if UI.CharacterAddedCallback then
			UI.CharacterAddedCallback(player, character)
		end
	end

	for _, character in next, workspace:WaitForChild('Characters'):GetChildren() do
		task.defer(onCharacterAdded, character)
	end

	workspace:WaitForChild('Characters').ChildAdded:Connect(function(character) 
		task.defer(onCharacterAdded, character) 
	end)

	services.RunService.Heartbeat:Connect(function()
		for Player, Highlight in next, HighlightStore do

			local DoesDraw = Toggles.ChamsEnabled.Value
			local IsTeamMate = ESP:IsTeamMate(Player)

			if not Toggles.ChamsShowTeams.Value and DoesDraw then
				DoesDraw = (not IsTeamMate)
			end

			local color 		= Toggles.ChamsTeamColors.Value and GetTeamColor(Player) or (IsTeamMate and Options.ChamsAllyFill.Value    or Options.ChamsEnemyFill.Value)
			local outlineColor  = Toggles.ChamsTeamColors.Value and GetTeamColor(Player) or (IsTeamMate and Options.ChamsAllyOutline.Value or Options.ChamsEnemyOutline.Value)

			local transparency = Options.ChamsTransparency.Value
			local outlineTransparency = Options.ChamsOutlineTransparency.Value

			if Player == Aimbot.target and Toggles.HighlightTarget.Value then
				color = ESP.HighlightColorDark
				outlineColor = ESP.HighlightColor
			end

			Highlight.FillColor 	= color
			Highlight.OutlineColor 	= outlineColor

			Highlight.FillTransparency 		= transparency
			Highlight.OutlineTransparency   = outlineTransparency
			Highlight.DepthMode 			= Options.ChamsMode.Value == 'Always show' and Enum.HighlightDepthMode.AlwaysOnTop or Enum.HighlightDepthMode.Occluded
			Highlight.Enabled 				= DoesDraw
		end
	end)
end
 

-- Anti cheat bypass
local CreateProxy, sigged do
	local FireServer, random = clonefunction(Instance.new('RemoteEvent').FireServer), clonefunction(getrenv().math.random)

	for _, fn in next, getgc() do
		if type(fn) == 'function' then 
			getfenv(v) -- bai bai lil luau optimization
		end
	end

	sigged = {}
	replaceclosure(getrenv().math.random, function(...)
		if select('#', ...) == 0 then return random(...) end
		if checkcaller() then return random(...) end

		local min = select(1, ...)
		local max = select(2, ...)

		if type(min) == 'number' and (min == 5 or min == 7) then 
			if type(max) ~= 'number' then
				syn_context_set(7) UI:Notify('Detected anticheat flagging mechanism!') syn_context_set(2)
				sigged[getinfo(3).func] = true -- sig that poop
			end
		end

		return random(...)
	end)

	local namecall
	namecall = hookmetamethod(game, '__namecall', function(self, ...)
		local args = { ... }
		local mthd = getnamecallmethod()

		if self.ClassName == 'RemoteEvent' and mthd == 'FireServer' then

			local level = 3
			local block = false
			while debug.validlevel(level) do
				if sigged[debug.getinfo(level).func] then block = true break end
				level = level + 1 
			end

			if block then
				syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (direct) (%s)', tostring(args[2]))) syn_context_set(2)
				return Instance.new('BindableEvent').Event:Wait()
			end
		end

		return namecall(self, ...)
	end)

	replaceclosure(Instance.new('RemoteEvent').FireServer, function(...)
		local self = select(1, ...)
		if typeof(self) ~= 'Instance' then return FireServer(...) end
		if self.ClassName ~= 'RemoteEvent' then return FireServer(...) end

		local level = 3
		local block = false
		while debug.validlevel(level) do
			if sigged[debug.getinfo(level).func] then block = true break end
			level = level + 1 
		end

		if block then
			syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (indirect) (%s)', tostring(args[2]))) syn_context_set(2)
			return Instance.new('BindableEvent').Event:Wait()
		end

		return FireServer(...)
	end)

	function CreateProxy(f)
		return function(...) -- since we can only have 1 upvalue :|
			return f(...)
		end
	end
end

local Storage = {}
do
	Storage.MarkedProjectiles = {}
	Storage.Random = Random.new()

	local ProjecitleConfigs = getupvalue(Tortoiseshell.Projectiles.InitProjectile, 1)

	-- backup functions
	local Fire, CastGeometryAndEnemies, Wait 

	local function FireProxy(self, event, ...)
		local args = { ... }

		if event == 'Item_Paintball' and args[1] == 'Shoot' then
			if Toggles.SilentAim.Value and Storage.Random:NextNumber(1, 100) <= Options.HitChance.Value and Options.SilentAimBind:GetState() then
				local stack = debug.getstack(3)
				local weaponData = debug.getupvalue(3, 4)

				local target = Aimbot.target;
				if target then
					local character = GetCharacter(target)
					local hitbox = character and character:findFirstChild('Hitbox')
					local root = character and character:findFirstChild('Root')
					local bone = hitbox and hitbox:findFirstChild(Aimbot.GetAimBone()) --Options.HitBone.Value)

					if bone then
						local origin = args[3]
						local template = weaponData.Projectile.Template
								
						local speed = ProjecitleConfigs[template].Speed
						local gravity = ProjecitleConfigs[template].Gravity

					--	syn_context_set(7) UI:Notify(string.format('Speed: %*', speed)) syn_context_set(2)

						local pos = Aimbot.VelocityPrediction(workspace.CurrentCamera.CFrame.p, bone.Position, root.Velocity, speed)
						local dir, travelTime = Aimbot.solveTime(origin, speed, pos, math.abs(gravity))

						if dir then
							local projectiles = stack[4]
							for i = 1, #projectiles do
								projectiles[i][1] = dir.unit * 60
							end
							setstack(3, 4, projectiles)
							args[4] = projectiles

							for _, p in next, projectiles do
								Storage.MarkedProjectiles[p[2]] = {
									Bone = bone,
									Character = character,
								}
							end

							if Toggles.DoubleTap.Value and (not UI.Block) then
								UI.Block = true
								local s, err = pcall(debug.info(3, 'f'))
								if not s then
									UI:Notify('DT ERR: ' .. tostring(err), 3)
								end
								UI.Block = false
							end
						end
					end
				end
			end

			local nups = getinfo(3).nups
			local recoilFunctionNames = { Recoil = true, WeaponRecoil = true, CameraRecoil = true }

			for i = 1, nups do
				local upv = getupvalue(3, i)
				if type(upv) == 'function' and recoilFunctionNames[getinfo(upv).name] then
					setupvalue(3, i, function(...)
						if Toggles.NoRecoil.Value then return end
						return upv(...)
					end)
				end
			end
		end

		if event == 'Character' and args[1] == 'State' then 
			if args[2] == 'Look' and Toggles.AntiAim.Value then
				args[3] = '-nan(ind)'
				Fire(self, "Character", "State", "Stance", "Prone")
			end
		end

		if args[1] == '__Hit' then
			local data = Storage.MarkedProjectiles[args[2]]
			if data then
				return Fire(self, "Projectiles", "__Hit", args[2], data.Bone.Position, data.Bone, Vector3.fromNormalId(Enum.NormalId.Top), data.Character)
			end
		end

		if sigged[debug.getinfo(2).func] then
			syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (module) (%s)', tostring(args[1]))) syn_context_set(2)
			return Instance.new('BindableEvent'
